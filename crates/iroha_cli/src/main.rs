//! Iroha CLI tool

use error_stack::{fmt::ColorMode, IntoReportCompat};
use eyre::Result;
use options::RunArgs;
use thiserror::Error;

mod client;
mod codec;
mod options;
mod wasm;

/// Top-level arguments for iroha
#[derive(clap::Parser, Debug)]
#[command(name = "iroha", version = concat!("version=", env!("CARGO_PKG_VERSION"), " git_commit_sha=", env!("VERGEN_GIT_SHA")), author)]
struct Args {
    /// Subcommands of iroha
    #[command(subcommand)]
    command: Command,
}

/// Subcomands of iroha cli
#[derive(clap::Subcommand, Debug)]
enum Command {
    /// Subcommands related to parity scale encoding
    Codec(codec::Args),
    /// Subcommands related to operations with smartcontracts
    Wasm(wasm::Args),
    /// Subcommands related to interactions with iroha peers Web API
    Client(client::Args),
}

macro_rules! match_all {
    ($self:ident, { $($variants:path),* $(,)?}) => {
        match $self {
            $($variants(variant) => RunArgs::run(variant),)*
        }
    };
}

impl options::RunArgs for Command {
    fn run(self) -> Result<()> {
        use Command::*;
        match_all!(self, { Codec, Wasm, Client })
    }
}

/// Errors generated by the top-level command
#[derive(Error, Debug, Copy, Clone)]
pub enum CommandError {
    /// Executing subcommand
    #[error("Failed to run the command")]
    Subcommand,
}

fn main() -> error_stack::Result<(), CommandError> {
    let Args { command } = clap::Parser::parse();

    error_stack::Report::set_color_mode(color_mode());

    command
        .run()
        .into_report()
        .map_err(|report| report.change_context(CommandError::Subcommand))?;

    Ok(())
}

fn color_mode() -> ColorMode {
    if supports_color::on(supports_color::Stream::Stdout).is_some()
        && supports_color::on(supports_color::Stream::Stderr).is_some()
    {
        ColorMode::Color
    } else {
        ColorMode::None
    }
}
